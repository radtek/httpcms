/**********************************************************************//**
 * @file us_grid_id.hpp
 *
 * Declares the grid identifier class.
 *************************************************************************/

#ifndef __US_GRID_ID_HPP__
#define __US_GRID_ID_HPP__

#ifndef __US_GRID_TYPE_HPP__
#include "us_grid_type.hpp"
#endif

#ifndef __US_GRID_SYSTEM_HPP__
#include "us_grid_system.hpp"
#endif

#include <stdint.h>
#include <string>

namespace unispace
{

	/**********************************************************************//**
	 * @class	us_grid_id
	 * @brief	网格ID类.<br>
	 * 			用于表示一个网格的编码标识。采用8Byte(128bit)的来存储网格的级别、类型、
	 * 			一维编码的ID。如果是米网格，还保存有横向坐标的带号信息。
	 * @author	yimin.liu@unispace-x.com
	 * @date	2016/3/18
	 *************************************************************************/

	class _US_GRID_SYSTEM_DLL us_grid_id
	{
		// 网格类为它的友元类，方便直接操作私有成员
		friend class us_grid_base;
		friend class us_grid_degree;
		friend class us_grid_meter;
	public:

		/**********************************************************************//**
		 * @brief	构造函数.
		 * @author	yimin.liu@unispace-x.com
		 * @date	2016/3/18
		 *
		 * @param type  网格类型.
		 * @param level 网格级别.
		 * @param id    网格一维编码(64bit).
		 *************************************************************************/
		us_grid_id(us_grid_type type, int level, uint64_t id);

		/**********************************************************************//**
		 * @brief	构造函数.
		 *			通过字符串构造网格ID，字符串的形式如同<b>us_grid_id(2,22,19,123456789
		 *			abcde0)</b>.
		 * @author	yimin.liu@unispace-x.com
		 * @date	2016/6/29
		 *
		 * @param	grid_str 网格全编码ID的字符串形式.
		 *************************************************************************/
		us_grid_id(const std::string& grid_str);

		/**********************************************************************//**
		 * @brief	拷贝构造函数.
		 * @author	yimin.liu@unispace-x.com
		 * @date	2017/4/7
		 * @param	other 网格ID.
		 *************************************************************************/
		us_grid_id(const us_grid_id& other);

		/**********************************************************************//**
		 * @brief	无参构造函数.
		 * @author	yimin.liu@unispace-x.com
		 * @date	2017/4/7
		 *************************************************************************/
		us_grid_id() {};

		/**********************************************************************//**
		 * @brief	获取网格类型.
		 * @author	yimin.liu@unispace-x.com
		 * @date	2016/3/18
		 * @return	网格type.
		 *************************************************************************/
		us_grid_type get_type()const;

		/**********************************************************************//**
		 * @brief	获取网格级别.
		 *			网格级别实际上代表了网格的精度，也就是网格的单位大小。网格一共分为32个级别。
		 *			31级网格代表最高精度级别的网格，0级网格代表初始划分的网格。初始划分的网格一
		 *			共是4个(2^1*2^1)，最高精度的网格一共是2^32*2^32=2^60个。网格从最初始划
		 *			分网格开始向下四叉分割，或者说从最精细网格开始向上四叉合并。<br>
		 *			level的值实际上还表示了网格ID取值中的有效位数(不包括符号位)。因为网格编码
		 *			中，坐标值的表示采取的是整数表示，网格等级实际上表示了其坐标中代表该网格的
		 *			必要位数。例如有一个网格level=15,坐标ID为[0x00fffff0,0x000fffff]，那么
		 *			表示的实际上是[0x00ff0000,0x000f0000]这个坐标的网格。对于坐标值前面16位
		 *			表示的是网格的坐标，后面部分实际对于该级别的网格是无效的。
		 * @author	yimin.liu@unispace-x.com
		 * @date	2016/3/18
		 * @return	网格level.
		 *************************************************************************/
		int get_level()const;

		/**********************************************************************//**
		 * @brief	获取网格一维编码ID.
		 * @author	yimin.liu@unispace-x.com
		 * @date	2016/3/18
		 * @return	网格一维编码ID.
		 *************************************************************************/
		uint64_t get_id()const;

		/**********************************************************************//**
		 * @brief	相等操作比较.
		 * @author	yimin.liu@unispace-x.com
		 * @date	2017/3/31
		 * @param	other	与之比较的网格ID
		 * @return	相等返回true,失败返回false.
		 *************************************************************************/
		bool operator== (const us_grid_id& other)const;

		/**********************************************************************//**
		 * @brief	判断与传入网格ID代表的网格是否有包含关系.
		 * @author	yimin.liu@unispace-x.com
		 * @date	2017/3/31
		 * @param	other	与之比较的网格ID
		 * @return	没有包含关系返回0，包含传入网格返回1，
		 *			被传入网格包含返回2。非同类型网格返回-1，不同分带的米网格返回-2.
		 *************************************************************************/
		int get_contain_status(const us_grid_id& other)const;

		/**********************************************************************//**
		 * @brief	获取该网格在父网格中的位置.
		 *			子网格在父网格中的位置，是按照反Z字形排列的，如下所示:<br>
		 *			+-----+-----+<br>
		 *			| 1,0 | 1,1 |<br>
		 *			+-----+-----+<br>
		 *			| 0,0 | 0,1 |<br>
		 *			+-----+-----+.
		 * @author	yimin.liu@unispace-x.com
		 * @date	2017/3/23
		 * @return	
		 *			|返回值|含义|
		 *			|---:|:---|
		 *			|0|位于左下角|
		 * 			|1|位于右下角|
		 *			|2|位于左上角|
		 *			|3|位于右上角|
		 *************************************************************************/
		int get_location_in_parent()const;

		/**********************************************************************//**
		 * @brief	获取父级网格的编码.
		 *			网格按照四叉分割而来，除了0级网格外，每一个网格都有一个父级网格。<br>
		 *			0级网格一共有四个，这四个本应该有一个共同的父级网格，但是在这里的编码中无法表示。
		 *			所以默认0级网格没有父级网格。
		 * @author	yimin.liu@unispace-x.com
		 * @date	2017/3/17
		 * @param	out_parent	传出父网格.
		 * @return	成功返回true，失败返回false.
		 *************************************************************************/
		 bool get_parent_grid_full_id(us_grid_id* out_parent)const;

		 /**********************************************************************//**
		 * @brief	获取四个子网格编码.
		 *			除了最精细级别(31级)的网格不能够再继续四叉分割外，所有的网格都可以分作四个子网格。
		 *			如果不需要某个方位的子网格，只需要对应的参数传NULL即可。
		 * @author	yimin.liu@unispace-x.com
		 * @date	2017/3/17
		 * @param	out_sub_lt	传出左上角子网格编码.
		 * @param	out_sub_rt	传出右上角子网格编码.
		 * @param	out_sub_lb	传出左下角子网格编码.
		 * @param	out_sub_rb	传出右下角子网格编码.
		 * @return	成功返回true，失败返回false.
		 *************************************************************************/
		bool get_sub_grid_full_id(us_grid_id* out_sub_lt, us_grid_id* out_sub_rt,
							 us_grid_id* out_sub_lb, us_grid_id* out_sub_rb)const;

		/**********************************************************************//**
		 * @brief	获取偏移网格.
		 *			<br>获取一个相对于本网格对象有一个偏移量的网格，偏移量由参数决定。<br>因为
		 *			各个级别的网格纵横向的分割都是有限的，所以偏移量不应该超过限制。如果超过限制
		 *			返回的将是把网格看作一个球，两个方向超过限制后回到原点，继续偏移到一个位置。
		 *			<br>例如:第1级网格一共是4*4=16个网格，如果对(1,0)网格偏移(1,2)就会获取到
		 *			(-2,-2)网格。
		 *			<pre>第1级网格，4x4(实际编码值可能会扩大2^30)
		 *			+-----+-----+-----+-----+
		 *			|-2,1 |-1,1 |0,1  |1,1  |
		 *			+-----+-----+-----+-----+
		 *			|-2,0 |-1,0 |0,0  |1,0  |
		 *			+-----+-----+-----+-----+
		 *			|-2,-1|-1,-1|0,-1 |1,-1 |
		 *			+-----+-----+-----+-----+
		 *			|-2,-2|-1,-2|0,-2 |1,-2 |
		 *			+-----+-----+-----+-----+
		 *			</pre>
		 * @author	yimin.liu@unispace-x.com
		 * @date	2017/3/17
		 * @param	out_gid		传出偏移后的网格编码.
		 * @param	horizontal	横向偏移量.
		 * @param	vertical	纵向偏移量.
		 * @return	成功返回true，失败返回false.
		 *************************************************************************/
		bool get_offset_grid_full_id(us_grid_id* out_gid, int horizontal, int vertical)const;


		/**********************************************************************//**
		 * @brief	设置网格类型.
		 * @author	yimin.liu@unispace-x.com
		 * @date	2016/3/18
		 * @param	type The type.
		 *************************************************************************/
		void set_type(us_grid_type type);

		/**********************************************************************//**
		 * @brief	设置网格级别(不做有效性判断)
		 * @author	yimin.liu@unispace-x.com
		 * @date	2016/3/18
		 * @param	level The level.
		 *************************************************************************/
		void set_level(int level);

		/**********************************************************************//**
		 * @brief	设置网格一维编码ID.
		 * @author	yimin.liu@unispace-x.com
		 * @date	2016/3/18
		 * @param	id	网格坐标的一维编码.
		 *************************************************************************/
		void set_id(uint64_t id);

		/**********************************************************************//**
		 * @brief	设置网格一维编码ID.
		 *			网格的一维编码ID由网格的二维编码ID二进制穿插组合而成。二进制穿插时纵向坐标
		 *			在前，横向坐标在后，各32位。
		 * @author	yimin.liu@unispace-x.com
		 * @date	2016/4/28
		 * @param	vertical	网格坐标的二维纵向编码.
		 * @param	horizontal	网格坐标的二维横向编码.
		 *************************************************************************/
		void set_id(uint32_t vertical, uint32_t horizontal);

		/**********************************************************************//**
		 * @brief	设置网格全编码ID.
		 *			网格的级别必须在[0,31]之间。网格的一维编码ID由网格的二维编码ID二进制穿插组合
		 *			而成。二进制穿插时纵向坐标在前，横向坐标在后，各32位。
		 * @author	yimin.liu@unispace-x.com
		 * @date	2016/6/13
		 * @param	type	网格的类型.
		 * @param	level	网格的级别.
		 * @param	id		网格坐标的一维编码.
		 *************************************************************************/
		void set_full_id(us_grid_type type, int level, uint64_t id);

		/**********************************************************************//**
		 * @brief	设置网格全编码ID.
		 *			网格的级别必须在[0,31]之间。网格的一维编码ID由网格的二维编码ID二进制穿插组合
		 *			而成。二进制穿插时纵向坐标在前，横向坐标在后，各32位。
		 * @author	yimin.liu@unispace-x.com
		 * @date	2016/6/13
		 * @param	type	网格的类型.
		 * @param	level	网格的级别.
		 * @param	vertical	网格坐标的二维纵向编码.
		 * @param	horizontal	网格坐标的二维横向编码.
		 *************************************************************************/
		void set_full_id(us_grid_type type, int level,
						 uint32_t vertical, uint32_t horizontal);

		/**********************************************************************//**
		 * @brief	设置网格全编码ID.
		 *			网格的级别必须在[0,31]之间。网格的一维编码ID由网格的二维编码ID二进制穿插组合
		 *			而成。二进制穿插时纵向坐标在前，横向坐标在后，各32位。
		 * @author	yimin.liu@unispace-x.com
		 * @date	2016/6/29
		 * @param	grid_str	网格全编码ID的字符串形式.
		 *************************************************************************/
		void set_full_id(const std::string& grid_str);

		/**********************************************************************//**
		 * @brief	网格编码标准化.
		 *			多余尾数位部分抹零.
		 * @author	yimin.liu@unispace-x.com
		 * @date	2017/4/6
		 *************************************************************************/
		void set_normalize();

		/**********************************************************************//**
		 * @brief	转换网格全编码ID为字符串形式.
		 *			转换得到的字符串形式如同<b>12345678-1234-1234-0123456789abcdef</b>,
		 *			即 us_grid_id(网格类型编码,级别,米网格带号,网格一维编码ID)。
		 * @author	yimin.liu@unispace-x.com
		 * @date	2016/6/29
		 * @return	网格全编码ID的字符串形式.
		 *************************************************************************/
		std::string to_string()const;

	public:

		/**********************************************************************//**
		 * @brief	<pre>
		 * 			双精度浮点数变成定点数，用int64_t表示.
		 *			将原double型的浮点数，转换为具有integer_width位整数位的定点数。
		 *			定点数的内存布局为【sign 1bit|int part|decimal part】
		 *			符号位单独占1位。integer_width只指定整数部分的bit位。
		 *			（这里并不是真正定点数表示法，实际上还是整数表示，这里这么说只是便于描述）
		 *			</pre>
		 * @author	yimin.liu@unispace-x.com
		 * @date	2016/3/18
		 *
		 * @param	value			待转换的浮点数.
		 * @param	integer_width	转换结果整数部分的bit数.
		 *
		 * @return	转换后的值(int64_t类型的).
		 *************************************************************************/
		static int64_t double_to_fixed_64(double value, int integer_width);


		/**********************************************************************//**
		 * @brief	双精度浮点数转换定点数，用int32_t表示.
		 *
		 * @author	yimin.liu@unispace-x.com
		 * @date	2016/3/18
		 * @param	value			待转换的浮点数.
		 * @param	integer_width	转换结果整数部分的bit数.
		 * @return	An int32_t.
		 *************************************************************************/
		static int32_t double_to_fixed_32(double value, int integer_width);


		/**********************************************************************//**
		 * @brief	单精度浮点数转换定点数，用int32_t表示.
		 *
		 * @author	yimin.liu@unispace-x.com
		 * @date	2016/3/18
		 * @param	value		  待转换的浮点数.
		 * @param	integer_width 转换结果整数部分的bit数.
		 * @return	An int32_t.
		 *************************************************************************/
		static int32_t float_to_fixed(float value, int integer_width);


		/**********************************************************************//**
		 * @brief	64bit的定点数转双精度浮点数.
		 *
		 * @author	yimin.liu@unispace-x.com
		 * @date	2016/3/18
		 * @param	value			待转换的64位的定点数.
		 * @param	integer_width	待转换数的整数位数.
		 * @return	A double.
		 *************************************************************************/
		static double fixed_64_to_double(int64_t value, int integer_width);


		/**********************************************************************//**
		 * @brief	32bit的定点数转double类型.
		 *
		 * @author	yimin.liu@unispace-x.com
		 * @date	2016/3/18
		 *
		 * @param value		    待转换的32位的定点数.
		 * @param integer_width 待转换数的整数位数.
		 * @return A double.
		 *************************************************************************/
		static double fixed_32_to_double(int32_t value, int integer_width);


		/**********************************************************************//**
		 * @brief	32bit的定点数转float类型.
		 *
		 * @author	yimin.liu@unispace-x.com
		 * @date	2016/3/18
		 * @param value		    待转换的32位的定点数.
		 * @param integer_width 待转换数的整数位数.
		 * @return A float.
		 *************************************************************************/
		static float  fixed_to_float(int32_t value, int integer_width);


		/**********************************************************************//**
		 * @brief	将两个uint32_t类型的值，二进制交叉成一个uint64_t类型的值.
		 *			二进制穿插是v1在前v2在后。例如 v1 = 0011 1011;v2 = 1111 0000，那么
		 *			组合后的结果是 0101 1111 1000 1010.
		 * 			此处请注意参数，传值的时候如果不是uint32类型，请先转换为uint32类型。
		 * @author	yimin.liu@unispace-x.com
		 * @date	2016/3/18
		 *
		 * @param v1 用于穿插组合的第一部分.
		 * @param v2 用于穿插组合的第二部分.
		 *
		 * @return An uint64_t.
		 *************************************************************************/
		static uint64_t binary_cross_combination(uint32_t v1, uint32_t v2);


		/**********************************************************************//**
		 * @brief	将一个uint64_t类型的值，二进制交叉拆解为两个uint32_t类型的值.
		 *
		 * @author	yimin.liu@unispace-x.com
		 * @date	2016/3/18
		 *
		 * @param value			The value.
		 * @param [out] out_v1	如果非null, 传出拆解后的第一部分.
		 * @param [out] out_v2	如果非null, 传出拆解后的第二部分.
		 * @return true if it succeeds, false if it fails.
		 *************************************************************************/
		static bool binary_cross_dismantle(uint64_t value, uint32_t* out_v1, uint32_t* out_v2);


	private:
		union
		{
			struct
			{
				uint16_t		m_invalid;	///< 无效占位
				int16_t			m_band;		///< 带数(仅在米网格中使用)(16bit)
				us_grid_type	m_type;		///< 网格类型(16bit)
				int16_t			m_level;	///< 级别[0,31](16bit)
				uint64_t		m_id;		///< 基本编码的的网格ID(64bit)
			};
			int32_t data[4];
		};
	};
}

#endif //!__US_GRID_ID_HPP__